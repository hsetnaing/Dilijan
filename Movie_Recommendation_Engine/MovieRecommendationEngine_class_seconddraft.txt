package MovieRecommendationEngine;

//purpose is to come up with a rating

import Reference.Pearson;
import com.sun.prism.impl.Disposer;

import java.io.*;
import java.nio.file.*;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.*;

public class MovieRecommendationEngine {

    static ArrayList<User> OldUsers = new ArrayList<User>(); //Keep info of all users in this arraylist
    private Path Movie;


    //purpose of function: record user's rating for a particular movie
    //input: UserID (cuz we're trying to find them)
    //input: MovieFile
    //TODO: change back to void
    private void RecordMovieRating(String MovieFile, ArrayList<User> ListofUsers) throws FileNotFoundException {

        File file = new File(MovieFile);
        Scanner sc = new Scanner(file);
        String userID;
        String rating;
        ArrayList<String> Ratings = new ArrayList<String>();
        ArrayList<Integer> Ratingsnum = new ArrayList<Integer>(Ratings.size());
        //int numrating; //to convert String rating to int, for the return statement

        if (sc.hasNextLine()) //I need to include this because I'm using Delimiter and I want to ignore the first line in each and every file
            sc.nextLine();

        while (sc.hasNextLine()) {
            Scanner read = new Scanner(sc.nextLine()); //we are creating a Scanner that reads this new line
            //starts reading every line in the text file
            read.useDelimiter(",");
            userID = read.next();
            rating = read.next();

            for (int i = 0; i < ListofUsers.size(); i++) {
                if (ListofUsers.get(i).ID.equals(userID)) {
                    //return rating (and movie)
                    //however, this means I need to look at the entire line and look at the thing after the delimiter
                    //Ratingsnum = Ratingsnum.add(Integer.parseInt(rating)); //converts String to int, for the return statement

                    MovieRating newMovieRating = new MovieRating(); //I need to create a new object of class MovieRating
                    newMovieRating.Rating = Integer.parseInt(rating); //records rating, but not name of movie
                    newMovieRating.Movie = MovieFile; //record name of movie
                    ListofUsers.get(i).MovieRatings.add(newMovieRating); //add the object to the MovieRatings array list

                    //ListofUsers.get(i).NumberOfMovies++; //increment number of movies to count how many they've watched

                    //System.out.println("I found the user");
                    //System.out.println(userID);
                    //System.out.println(rating);
                }
            }
        }

        for(int j = 0; j <ListofUsers.size(); j++) {
           // System.out.println("RecordMovieRating: " + ListofUsers.get(j).ID+ ", " + ListofUsers.get(j).MovieRatings);

        }

        if (ListofUsers.get(0).ID.equals("2059652")){
            //System.out.println("first person's movie array size: "+ListofUsers.get(0).MovieRatings.size());

        }
        //System.out.println("I DIDN'T find the user");

        //at this point, we cannot find the user we're looking for in this movie file.


    }

    private boolean checkIfNew(String UserID) {
        for (int i = 0; i < OldUsers.size(); i++) {
            if (OldUsers.get(i).ID.equals(UserID)) {
                return false;
            }
        }
        return true;
    }

    /*
    private void printUser(User user) {
        System.out.println("User : {ID:" + user.ID + ", mean:" + user.mean + ", SD:" + user.SD + ", count:" + user.NumberOfMovies);
        System.out.println(", MovieRatings: [");
        for (int i = 0; i < user.MovieRatings.size(); i++) {
            System.out.println("{Movie:" + user.MovieRatings.get(i).Movie + ", Rating:" + user.MovieRatings.get(i).Rating + "}");
        }
        System.out.println("]}");
    }
     */


    //return UserID ArrayList
    private ArrayList<String> ReturnUserID(String MovieFile) throws FileNotFoundException {
        File file = new File(MovieFile); //read file
        Scanner sc = new Scanner(file); //create new Scanner

        ArrayList<String> UserIDArrayList = new ArrayList<>();

        //read the first line. after this function, rest of the text is left. this ignores the "1:"
        if (sc.hasNextLine()) {
            sc.nextLine();
        }

        while (sc.hasNextLine()) { //Scanner is connected directly to the file, and it reads it. Does it have next line?

            Scanner scanner = new Scanner(sc.nextLine()); //we are creating a Scanner that reads this new line
            scanner.useDelimiter(","); //only reads what comes before ",", everything else is ignored
            //now scanner is looking at the very first user ID

            //String input = sc.nextLine();
            UserIDArrayList.add(scanner.next()); //adds new empty bucket, put value inside bucket

        }
        //System.out.println(UserIDArrayList);
        return UserIDArrayList;
    }


    //writing our own function instead of using HashMap
    //FindUserIndex goes through each element inside Users,
    // compares UserID with the UserID inside of each element in the class User
    // and see if the user is there
    //i.e. see if we already have him in the database/his info is already recorded


    //Open all movie files to find first person in Array List (and record their rating)
    //Records rating, movies watched, mean and SD of a user
    //output: ArrayList of type Object
    //The list of users input should be exactly the same as the list of users output

    //TODO: change output back to ArrayList<User>
    private ArrayList<User> RecordUserInfo(ArrayList<String> ListofUsers) throws FileNotFoundException {
        //there are 2205 movies

        //future use: have a function to check if this person is an OldUser

        //if new user: record their data

        //create a new user, assign its ID value and append to OldUsers
        //go through each movie file,use function ReadFile,
        // record rating & store it (condition: if user exists, record movie name too)
        //check: prints OldUsers array list


        //TODO: check with Davyd. changed type from String to User.
        ArrayList<User> newUsers = new ArrayList<User>();

        for (int i = 0; i < ListofUsers.size(); i++) {
            if (checkIfNew(ListofUsers.get(i))) {
                User newUser = new User();
                newUser.ID = ListofUsers.get(i);
                newUsers.add(newUser);
            }
        }

        //test
        for(int num = 0; num < newUsers.size(); num++) {
           // System.out.println("These are the new users: " + newUsers.get(num).ID);
        }


        //RecordMovieRating records ratings
        ArrayList<String> movies = GetListofAllMovies();

        for (int i = 0; i < movies.size(); i++) {

            RecordMovieRating("moviedata/" + movies.get(i), newUsers);

        }
        System.out.println("newUsers size: "+newUsers.size());
        System.out.println("third person movie array size: "+newUsers.get(2).MovieRatings.size());

        //test
        for(int j = 0; j < newUsers.size();j++) {

            for (int k = 0; k < newUsers.get(j).MovieRatings.size(); k++) {
                //System.out.println("User: " + newUsers.get(j).ID + ", Movie: " + newUsers.get(j).MovieRatings.get(k).Movie + ", Rating: " + newUsers.get(j).MovieRatings.get(k).Rating);
            }
        }
        //newUsers list only has ID, rating at this point
        //System.out.println(newUsers.size());
        //System.out.println(newUsers.get(0).ID);
        //System.out.println("the size of 127122: "+ newUsers.get(144).MovieRatings.size());

        for (int i = 0; i < newUsers.size(); i++) {
            //record mean and SD here outside of for loop after all movie/rating data has been collected

            double UserMean;
            double sum = 0;

            //adds all the ratings for a user
            for (int k = 0; k < newUsers.get(i).MovieRatings.size(); k++) {
                sum = sum + newUsers.get(i).MovieRatings.get(k).Rating;
            }

            //UserMean = sum / newUsers.get(i).NumberOfMovies;
            UserMean = sum / newUsers.get(i).MovieRatings.size();
            newUsers.get(i).mean = UserMean; //assign mean value to the new user

            //now for standard deviation
            //for each rating, subtract mean from it. then square the result.
            //find mean of all those squared differences.
            //take the square root of answer found above.

            double subtractedresult = 0;
            double squaredresult = 0;

            ArrayList<Double> SquaredDifferences = new ArrayList<>(); //create array list for squared differences

            for (int z = 0; z < newUsers.get(i).MovieRatings.size(); z++) {
                subtractedresult = newUsers.get(i).MovieRatings.get(z).Rating - UserMean;
                squaredresult = subtractedresult * subtractedresult; //square
                SquaredDifferences.add(squaredresult); //appends squared result to array list
            }

            double SquareDiffMean;
            double UserSD;
            double sum2 = 0;

            for (int y = 0; y < SquaredDifferences.size(); y++) {
                sum2 = sum2 + SquaredDifferences.get(y);
            }
            SquareDiffMean = sum2 / SquaredDifferences.size();

            UserSD = Math.sqrt(SquareDiffMean);
            newUsers.get(i).SD = UserSD;

            //printUser(newUsers.get(i));
        }
        //now all essential info recorded for newUsers

        //Check results
        /*
       System.out.println(newUser.ID);
        for(int num = 0; num < newUser.MovieRatings.size(); num++) {
            System.out.println(newUser.MovieRatings.get(num).Movie);
            System.out.println(newUser.MovieRatings.get(num).Rating);
        }
        System.out.println(count);
        System.out.println(UserMean);
        System.out.println(SquaredDifferences);
        System.out.println(UserSD);
        System.out.print(OldUsers);

         */
        //System.out.println("This is what I'm looking for " + OldUsers);
        //System.out.println(ListofUsers);
        //add newUsers to old users array list
        for (int i = 0; i < newUsers.size(); i++) {
            OldUsers.add(newUsers.get(i));
        }

        //why we need one last function?
        //input array list is not equal to output array list
        //if they are old users, we're not adding them to the newUsers array list
        //if old users already exist in input array list, the output array list will be missing some people
        //our final function wants to convert the String array list to an Object array list, with all the additional info
        //basically String -> Object array list conversion
        //example
        /*
        for(int a = 0; a < StringNeighbours.size(); a++){
            User newUser = new User();
            newUser.ID = StringNeighbours.get(a);
            Neighbours.add(newUser);
        }
         */

        //function for-loop
        //Loop through the original <String>ListofUsers array list
        //now every user is part of <User>OldUsers array list right?
        //find them first
        //then get(i) it
        //add it to the output array list

        //reminder: every person is now an OldUser
        ArrayList<User> outputUsers = new ArrayList<User>(); //the output for this function
        for (int i = 0; i < ListofUsers.size(); i++) {

            int index = 0;
            index = FindUserIndex(ListofUsers.get(i)); //this throws the ID inside FindUserIndex's argument
            User newOutputUser = new User();

            //their info in the OldUsers array list is copied to the outputUsers array list
            newOutputUser.ID = ListofUsers.get(i);
            newOutputUser.mean = OldUsers.get(index).mean;
            newOutputUser.SD = OldUsers.get(index).SD;
            newOutputUser.NumberOfMovies = OldUsers.get(index).NumberOfMovies;
            newOutputUser.MovieRatings = OldUsers.get(index).MovieRatings;

            outputUsers.add(newOutputUser);

        }
        //outsource the task to a function outside this RecordUserInfo
        //it should be find them

        //the function return Object
        //private int FindUserIndex(String UserID)

        //or it returns the index in oldusers array list

        //finish the code using FindUserIndex
        //hint for FindUserIndex -> use checkIfNew function as reference
        //you could actually remove checkIfNew function from everywhere
        //useFindUserIndex instead (it will return -1 if user is new, return index if user is old)


        //test
        for(int hello=0; hello<outputUsers.size(); hello++) {
            //System.out.println("The ID: "+outputUsers.get(hello).ID +", the mean: "+ outputUsers.get(hello).mean + ", the SD: " + outputUsers.get(hello).SD);
        }

        return outputUsers; //array list of users of type <Object> (specifically <Users>)

    }

    /*
     private boolean checkIfNew(String UserID) {
        for (int i = 0; i < OldUsers.size(); i++) {
            if (OldUsers.get(i).ID.equals(UserID)) {
                return false;
            }
        }
        return true;
    }
     */

    //returns index in OldUsers array list
    //input is user's ID
    //output is that user's location in the OldUsers array list, else
    //output is -1 if that person is new
    private int FindUserIndex(String UserID){
        //go through the IDs of the array
        //return the index
        int index = -1;
        for(int j = 0; j < OldUsers.size(); j++) {
            if (OldUsers.get(j).ID.equals(UserID)) {
                index = j;
                break;
            }
        }
        return index;
    }


    //output is Array list of ALL movies
    public ArrayList<String> GetListofAllMovies() {

        ArrayList<String> AllMovies = new ArrayList<String>();

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("moviedata"))) {
            for (Path file : stream) {
                Movie = file.getFileName();
                AllMovies.add(Movie.toString());
            }

        } catch (IOException | DirectoryIteratorException ex) {
            System.err.println(ex);
        }
        //System.out.println(AllMovies);

        return AllMovies;
    }


    //constructor
    //public Animal();
    private MovieRecommendationEngine() throws FileNotFoundException {
        //Animal = breathe();
        //Animal = eat();
        //Animal = die();


    }

    //ArrayList<CommonMovie> CommonMovies = new ArrayList<CommonMovie>();


    // input: User A and B from User class, which has all their info.
    // output: A list of movies A and B have watched.
    //Pearson calls commonRatings
    private ArrayList<CommonMovie> commonRatings(User A, User B) {

        /*
                    MovieRating newMovieRating = new MovieRating(); //I need to create a new object of class MovieRating
                    newMovieRating.Rating = rating; //records rating, but not name of movie
                    newMovieRating.Movie = movies.get(i); //record name of movie
                    newUser.MovieRatings.add(newMovieRating); //appends the object (newMovieRating) to arraylist 'MovieRatings'
                    count++;

         */
        /*
                    User newUser = new User(); //create a new user. newUser is an object - treat it like a human being.
         */

        ArrayList<CommonMovie> CommonMovies = new ArrayList<CommonMovie>(); //this creates an empty list that we will use to store data i.e. list of movies A and B watched. The type is a class 'CommonMovie'

        //CommonMovie newCommonMovie = new CommonMovie(); //I need to create a new object of class CommonMovie
        //placing this here
        //overwrites objects instead of adding them

        String MovieName;
        double rA; //User A's rating
        double rB; //User B's rating

        //test
        //System.out.println("A's ID"+A.ID);
        //System.out.println("B's ID"+B.ID);
        //System.out.println(A.MovieRatings.size());
        //System.out.println(B.MovieRatings.size());
        /*
        for(int g=0; g< A.MovieRatings.size(); g++){
            System.out.println("Movies User A has watched: " + A.MovieRatings.get(g).Movie + ", " + A.MovieRatings.get(g).Rating);
        }

        for(int h=0; h< B.MovieRatings.size(); h++){
            System.out.println("Movies User B has watched: " + B.MovieRatings.get(h).Movie + ", " + B.MovieRatings.get(h).Rating);
        }

         */

        //System.out.println("are you even here");
        //System.out.println("OldUsers: "+OldUsers.size());
       //System.out.println("A's size: "+ A.MovieRatings.size());
        //System.out.println("B's size: "+ B.MovieRatings.size());

        //end of test

        int start = 0;
        for (int i = 0; i < A.MovieRatings.size(); i++) {

            //System.out.println("inside the first loop");

            for (int j = start; j < B.MovieRatings.size(); j++) {


                if (A.MovieRatings.get(i).Movie.equals(B.MovieRatings.get(j).Movie)) { //condition 3



                    CommonMovie newCommonMovie = new CommonMovie(); //I need to create a new object of class CommonMovie

                    //do we have a common movie? yes. now add it to the array list
                    MovieName = A.MovieRatings.get(i).Movie; //we got the movie! Now we store it in this variable.
                    //System.out.println(MovieName);
                    newCommonMovie.Name = MovieName; //now it's also stored in the class

                    //let's also store A and B's ratings for this movie
                    rA = A.MovieRatings.get(i).Rating;
                    rB = B.MovieRatings.get(j).Rating;

                    //Now let's store it in the object CommonMovie class
                    newCommonMovie.ri = rA;
                    newCommonMovie.rj = rB;

                    //System.out.println(newCommonMovie.Name + " " + newCommonMovie.ri + " " + newCommonMovie.rj);

                    CommonMovies.add(newCommonMovie); //the array is in the newCommonMovie class
                    //System.out.println(newCommonMovie.Name + " " + newCommonMovie.ri + " " + newCommonMovie.rj);

                    //commonMovies.add(A.MovieRatings.get(i).Movie);
                    start = j + 1;
                    break;
                } else if (A.MovieRatings.get(i).Movie.compareTo(B.MovieRatings.get(j).Movie) < 0) { //condition 1 //s1 < s2 returns negative value
                    break;  //breaks inner for loop -> i = i+1
                } else {
                    start = j + 1; //condition 2
                }
            }
        }

        //System.out.println("Common movies for user A and B: "+ CommonMovies);
        //System.out.println("Number of movies in common: " + CommonMovies.size());
        //System.out.println(CommonMovies.get(1).Name);
        //System.out.println(CommonMovies.get(1).ri);
        //System.out.println(CommonMovies.get(1).rj);

        //CommonMovies : {Name: ____, ri:___, rj:_____}
        /*
        CommonMovie newCommonMovie = new CommonMovie();
        for(int h = 0; h < CommonMovies.size(); h++) {
            System.out.println("Common Movies: {Name: " + newCommonMovie.Name + ", ri: " + newCommonMovie.ri + ", rj: " + newCommonMovie.rj);
        }
         */

       // System.out.println(CommonMovies.size());

        //return commonMovies; //list of movies A and B both watched
        return CommonMovies;    //this is the array in the class
        //return commonMovies; //output requires an array list. so there it is. Type is <Object> not <String>. <Object> here is <CommonMovie>

    }


    //TODO: Pearson's coefficient
    /* Formula:
   for movie 1,
   Find (User A's rating - their mean) = X
   Find (User B's rating - their mean) = Y
   Find the product XY.
   XY1 -> ratings for movie 1
   XY2 -> ratings for movie 2 etc.
   For n common movies,
   Find sum of XY1 + XY2 + .. + XYn = SUM
   Divide this sum by number of common ratings -> SUM/n.
   Eij = SUM/n
     */

    //I called Pearson in NeighboursPearson function
    private double Pearson(User A, User B) {
        //First find Ei,j
        double Eij;
        double SUM = 0;
        double Pearsons;
        double rik;
        double rjk;

        ArrayList<CommonMovie> CommonMovies;

        CommonMovies = commonRatings(A,B); //commonRatings function outputs an array list of type Object <CommonMovies)/list of movies A and B have watched.

        //System.out.println(CommonMovies.size()); //TODO: there is a problem here. it's 0

        //First result = numerator
	        for (int k = 0; k < CommonMovies.size(); k++) { //for every movie
              //String Movie = commonRatings(A,B).get(k);
                rik = CommonMovies.get(k).ri;
                //System.out.println(rik);
                rjk = CommonMovies.get(k).rj;
                //System.out.println(rjk);
                SUM = SUM + (rik - A.mean) * (rjk - B.mean);
                //System.out.println(SUM);
            }
        //System.out.println("SUM: " +SUM);
        Eij = SUM / CommonMovies.size();
	     //System.out.println("Common Movies: "+CommonMovies.size());
        //System.out.println("Eij: "+Eij);
        Pearsons = Eij / (A.SD * B.SD);
        //System.out.println("This is User A's ID: " + A.ID);
        //System.out.println("This is User B's ID: " + B.ID);
        //System.out.println("This is User A's SD: " + A.SD);
        //System.out.println("This is User B's SD: " + B.SD);
        //ln("This is User A's mean: " + A.mean);
        //System.out.println("This is User B's mean: " + B.mean);


        if(B.ID.equals("2625420")){
            System.out.println("SUM: " +SUM);
            System.out.println("Eij: "+Eij);
            System.out.println("SD: "+B.SD);
            System.out.println("SD: "+A.SD);
            System.out.println(CommonMovies.size());
        }

        //System.out.println("This is Pearson's coefficient: " + Pearsons);

        return Pearsons;
    }

    private void CountStuff() throws FileNotFoundException {

        System.out.println(ReturnUserID("moviedata/mv_0000002.txt").size());

    }

    private int FindUserIndexNeighbours(String UserID){
        //go through the IDs of the array
        //return the index
        int index = -1;
        for(int j = 0; j < OldUsers.size(); j++) {
            if (OldUsers.get(j).ID.equals(UserID)) {
                index = j;
                break;
            }
        }
        return index;
    }

    //oldusers array list will be filled with neighbours
    private ArrayList<User> FindNeighbours(String UserID) throws FileNotFoundException {
        //String UserID is the chosen person. We're removing them from the array list
        ArrayList<User> Neighbours = new ArrayList<User>(); //should exclude chosen user. this array is currently empty
        ArrayList<String> StringNeighbours = (ArrayList)ReturnUserID("moviedata/mv_0000002.txt").clone();
        //StringNeighbours.remove(UserID); //list has now been modified

        //RecordUserInfo(StringNeighbours);

        //String to Object array list conversion
        /*
        for(int a = 0; a < StringNeighbours.size(); a++){
            User newUser = new User();
            newUser.ID = StringNeighbours.get(a);
            Neighbours.add(newUser);
        }

         */

        Neighbours = RecordUserInfo(StringNeighbours); //this is now an array list of type object...

        System.out.println("neighbours with chosen user size: "+Neighbours.size());



        //other method: for loop to go through neighbours list and remove UserA if the ID matches
        int index;
        for(int i = 0; i<Neighbours.size(); i++){
            if(Neighbours.get(i).ID.equals(UserID)) {
                index = i;
                Neighbours.remove(index);
            }
        }

        System.out.println("neighbours without chosen user size: "+Neighbours.size());
        System.out.println("inside find neighbours: "+Neighbours.get(0).MovieRatings.size());
        System.out.println(Neighbours.get(0).ID);



        return Neighbours;
    }

    private ArrayList<Pearsons> NeighboursPearson() throws FileNotFoundException {
        //User A = 1283204
        String ChosenUser = "1283204";
        User UserB;
        User UserA;

        //array list just for userA bc we need to have their info recorded in OldUsers array list
        //recorduserinfo(userA)

        //ArrayList<String> JustUserA = new ArrayList<>();
        //JustUserA.add(ChosenUser);
        //RecordUserInfo(JustUserA); //the output is an arraylist of type Object

        ArrayList<User> Neighbours = new ArrayList<>();
        Neighbours = FindNeighbours(ChosenUser); //this is my array list of neighbours of type Object <User> //RecordUserInfo called in FindNeighbours

        System.out.println("inside neighbours pearson: "+Neighbours.size());

        int index = FindUserIndex(ChosenUser); //index of UserA in OldUsers array list
        UserA = OldUsers.get(index);
        // System.out.println("this is UserA's ID: " +UserA.ID);


        double value = 0;
        //System.out.println(Neighbours.get(0).MovieRatings.size());
        value = Pearson(UserA, Neighbours.get(0));
        //System.out.println("value: "+value);

        /*
        ArrayList<Double> PearsonNeighbours = new ArrayList<>();

        //System.out.println("Pearson for A and first person: "+ Pearson(UserA,Neighbours.get(0)));

        //calculate Pearson and store it in an array
        for(int i = 0; i < Neighbours.size(); i++) {
            //User UserB = new User();
            UserB = Neighbours.get(i);
            //Pearson(UserA,UserB); //arguments: User A, User B
            // System.out.println("This is User B's ID: " + UserB.ID);
            PearsonNeighbours.add(Pearson(UserA,UserB)); //adding the pearson result to array list
        }

         */

        //System.out.println("Double array list: " + PearsonNeighbours);
        //object instead of double
        //2 - id of user in the neighbours array list, (double) Pearson coefficient
        //sort according to the Pearson
        //I'll know the 5 highest Pearsons

        //create the PearsonNeighboursList arraylist
        ArrayList<Pearsons> PearsonNeighboursList = new ArrayList<>();

        //append a new Pearsons object to the PearsonNeighboursList
        for(int i = 0; i < Neighbours.size(); i++) {
            UserB = Neighbours.get(i);
            Pearsons newPearsons = new Pearsons();
            newPearsons.PearsonCo = Pearson(UserA,UserB); //adding the pearson result to array list
            newPearsons.ID = UserB.ID;
            PearsonNeighboursList.add(newPearsons);

        }

        //this prints everyone in their list, incl. their ID and P's coefficient
        for(int j=0; j<PearsonNeighboursList.size(); j++) {
            //System.out.println("ID: "+PearsonNeighboursList.get(j).ID + ", Pearson's coefficient: " + PearsonNeighboursList.get(j).PearsonCo);
        }
        //System.out.println("this should be size of array before removing undesirables: "+PearsonNeighboursList.size());

        //create new object of that type
        //assign value to attribute of object
        //append object to arraylist of type object

        //remove Pearson's Coefficients that are out of range and are NaN
        for(int j =0; j<PearsonNeighboursList.size();j++){
            if(PearsonNeighboursList.get(j).PearsonCo > 1 || PearsonNeighboursList.get(j).PearsonCo < -1 || Double.isNaN(PearsonNeighboursList.get(j).PearsonCo)){
                PearsonNeighboursList.remove(j);
            }
        }
        //System.out.println("this should be size of array after removing undesirables: "+PearsonNeighboursList.size());

        //Print final PearsonNeighboursList (unsorted)
        for(int jaguar=0; jaguar<PearsonNeighboursList.size(); jaguar++) {
           //System.out.println("unsorted list: ID: "+PearsonNeighboursList.get(jaguar).ID + ", Pearson's coefficient: " + PearsonNeighboursList.get(jaguar).PearsonCo);
        }

       // System.out.println("this should be size of sorted array after removing undesirables: "+PearsonNeighboursList.size());

        //sort in descending order
        Collections.sort(PearsonNeighboursList, Collections.reverseOrder());

        //print sorted list
        for(int jelly =0; jelly<PearsonNeighboursList.size(); jelly++){
           // System.out.println("Sorted list: "+PearsonNeighboursList.get(jelly).ID + ", Pearson's coefficient: "+PearsonNeighboursList.get(jelly).PearsonCo);
        }

        //print top 5
        for(int jupiter =0; jupiter<5; jupiter++){
           // System.out.println("top 5: "+PearsonNeighboursList.get(jupiter).ID + ", Pearson's coefficient: "+PearsonNeighboursList.get(jupiter).PearsonCo);

        }

        //new array list with just top 5
        ArrayList<Pearsons> KNN = new ArrayList<>();

        //append the objects to the new array list
        for(int jupiter =0; jupiter<5; jupiter++){
            KNN.add(PearsonNeighboursList.get(jupiter));
        }

        //System.out.println(KNN.size());
        return KNN;


    }

    private void PredictRating() throws FileNotFoundException {
        //Predicted rating:
        //Top SUM = A and j's pearson's coefficient*(rating j gave to movie m - j's mean) + A and l's pearson coefficient*(rating l gave to movie m - j's mean)+...
        //Bottom SUM = magnitude of (A and j's pearson's coefficient + A and l's pearson's coefficient... +...)
        //Predicted rating = (Top SUM/Bottom SUM) + A's mean


        //required values:
        //the Pearson's coefficient of top 5
        //the rating of top 5 for movie m
        //mean of each top 5
        //mean of user A

        ArrayList<Pearsons> KNN = new ArrayList<>();
        KNN = NeighboursPearson();

        double predictedrating = 0;
        double rjm = 0;
        double mean = 0;
        int foundindex;
        double SUM = 0;
        double BOTTOMSUM = 0;



        for(int q = 0; q < KNN.size(); q++) {

            foundindex = FindUserIndex(KNN.get(q).ID); //we got the index of first person in oldusers array list

            //get User B's rating for Movie M
            for(int r = 0; r < OldUsers.get(foundindex).MovieRatings.size(); r++) {
                if (OldUsers.get(foundindex).MovieRatings.get(r).Movie.equals("moviedata/mv_0000002.txt")){
                    rjm = OldUsers.get(foundindex).MovieRatings.get(r).Rating;
                    mean = OldUsers.get(foundindex).mean;

                    //test
                    System.out.println("UserID: " + OldUsers.get(foundindex).ID + ", rjm: " + rjm + ", mean: " + mean);
                    break;
                }
            }
            SUM = SUM + KNN.get(q).PearsonCo * (rjm - mean);
        }

        for (int k=0; k <KNN.size(); k++){
            System.out.println("Pearson's coefficient in order: "+KNN.get(k).PearsonCo);
        }


        //Denominator
        for (int j=0; j<KNN.size();j++){
            BOTTOMSUM = BOTTOMSUM + Math.abs(KNN.get(j).PearsonCo);
        }

        //UserA
        String IDUserA = "1283204";
        double userAmean = 0;
        int userAindex=0;
        userAindex = FindUserIndex(IDUserA);
        userAmean = OldUsers.get(userAindex).mean;
        int movieindex = 0;

        predictedrating = (SUM / BOTTOMSUM) + userAmean;
        System.out.println("User A's mean: "+userAmean);

        System.out.println("User A's predicted rating is: " + predictedrating);

        for(int r = 0; r < OldUsers.get(userAindex).MovieRatings.size(); r++) {
            if (OldUsers.get(userAindex).MovieRatings.get(r).Movie.equals("moviedata/mv_0000002.txt")) {
                movieindex = r;
            }
        }

        System.out.println("User A's actual rating is: " + OldUsers.get(userAindex).MovieRatings.get(movieindex).Rating);

        //return predictedrating;
    }

    private void RMSEUser(){

    }





    /*
    private void FindkNN() throws FileNotFoundException {

        ArrayList<Pearsons> PearsonsNeighboursList = (ArrayList)NeighboursPearson().clone();
        //PearsonsNeighboursList = NeighboursPearson();
        System.out.println(PearsonsNeighboursList.size());
        System.out.println("139's ID: "+PearsonsNeighboursList.get(139).ID + "139's Pearson's coefficient: "+PearsonsNeighboursList.get(139).PearsonCo);

    }

     */



    //TODO: kNN
    /*
    the kNN thing:
    User A: 1283204
    say they watched movie m = mv_0000002.txt
    Everyone in that list are A's neighbours. let N= number of Neighbours
    I have to find Pearson's coefficient between A and these ppl, so there will be N number of Pearson's coefficient
    Store these numbers in array
    Rank numbers in descending order
    Choose top 5.
     */
    /*tip: use input/output (functions have value - use that)

    //output should be an array list of 5 users
    private ArrayList<User> kNN(User A, ArrayList<User> Neighbours, int k=5) {
        //Choose five top ones, output give top ones.
        //Neighbours - everybody in list except chosen person
        //calculate Pearson between A and neighbours


        //GO through entire array of OldUsers
        //Find Pearson between A and each element from OldUsers
        //Choose k biggest Pearsons and return k elements that gave those values
        //try k = 5
    }

    private double Predict(User A, Movie M) {


    }
    predict(User A, Movie M) -> using all functions I've already written
            //find neighbours
            //call kNN function with neighbours


     */
    /*
    the kNN thing:
    User A: 1488884
    say they watched movie m = mv_0000002.txt
    Everyone in that list are A's neighbours. let N= number of Neighbours
    I have to find Pearson's coefficient between A and these ppl, so there will be N number of Pearson's coefficient
    Store these numbers in array
    Rank numbers in descending order
    Choose top 5.

    Now plug it into the formula

    Predicted rating:
    Top SUM = A and j's pearson's coefficient(rating j gave to movie m - j's mean) + A and l's pearson coefficient... + ...
    Bottom SUM = magnitude of (A and j's pearson's coefficient + A and l's pearson's coefficient... +...)
    Predicted rating = (Top SUM/Bottom SUM) + A's mean

     */


    public static void main(String[] args) throws Exception {

        long startTime = System.currentTimeMillis();

        MovieRecommendationEngine Engine = new MovieRecommendationEngine(); //as soon as we start the engine, we go through the file and record everyone's ID and ratings
        //Engine.ReadFile();
        //ArrayList<String> Users = Engine.ReturnUserID("moviedata/mv_0000002.txt");
        //Engine.ReturnUserID("moviedata/mv_0000001.txt");

        //Engine.ReturnUserID("moviedata/mv_0000002.txt");

        //System.out.println(Users);

        //test
        //Engine.RecordUserInfo(new ArrayList<String>("1488844","1209119")); //throw in variable, can't hardcode
        //ArrayList<String> Users = new ArrayList<String>();
        //Users.add("1488844");
        //Users.add("1209119");

        //uncomment
        //Engine.RecordUserInfo(Users);
        //ArrayList<User> OldUsersList = OldUsers;
        //Engine.commonRatings(OldUsers.get(0), OldUsers.get(1));
        //Engine.Pearson(OldUsers.get(0), OldUsers.get(1));
        //(test)System.out.println(Engine.commonRatings(OldUsers.get(0),OldUsers.get(1)));

        //Engine.RemovePrintTest(); //testing if can remove object to create neighbours array list
        //Engine.CountStuff();
        //Engine.NeighboursPearson();
        Engine.PredictRating();
        //Engine.FindkNN();


        long endTime   = System.currentTimeMillis();
        long totalTime = endTime - startTime;
        //System.out.println(totalTime);

        NumberFormat formatter = new DecimalFormat("#0.00000");
        System.out.print("Execution time is " + formatter.format((endTime - startTime) / 1000d) + " seconds");

        //Animal Dog = new Animal();
        //Animal Dolphin = new Animal();
    }
}



//new Dolphin class extends Animal
    //distinctive properties of Dolphin inside constructor
    //you can put random values for the variables
    //or create a specific dolphin
    //pass arguments in constructor (choose variables you want)
    //then you can name your Dolphin
    //what is outside the constructor? Variables such as: tail length, colour of dolphin


    //What's Abo's rating  for Zootopia?
    //find users who watched Zootopia
    //find Pearson's coefficient between them and Abo
    //              Loop required. We need to go through all Zootopia watchers and calculate Pearson's coeefficient for each person w/ Abo
    //Rank Pearson's coefficients and choose K highest
    //Use final formula to predict Abo's rating

    //Which users watched Zootopia? (index 14)
    //Open file movie_0014
    //Record their ID and return the data

    //Find Pearson's coefficient between A and B
    //To find Pearson's coefficient: Find SD of both, we find Eij

    //TODO: do for one person for now, start small.
    //Find SD for Zootopia people
    //Example: there are 10 people, excluding Abo. In the movie file you will see 11 people.
    //Start with Person A.
    //Open movie file 1-100.
    //      Open movie file 1. Find Zootopia Users. Record their rating. Record the movies they've watched.
    //      Repeat from file 2-100.
    //Calculate SD.
    //  Calculate mean
    //  Plug into formula to find
    //  Create a map from movie to rating for each user. When you look up the user, you can go to their map. The map has key and value. key = movie, value = rating.
    //
    // Store the info in class User for later use
    //

    //think about using hash map
    //





    /*
    What's Abo's rating for Zootopia?

    His mean rating
    How many movies he watched

    We are looking for set K (five closest neighbours) How do we find nearest neighbours?
    How many other users also watched Zootopia?
    What rating did they give Zootopia?
    What's their mean rating? (for all movies they watched)

    We need to find the Pearson coefficient

    missing a step

    After finding pearson coefficient, we have all the info we need
    we just need to plug it inside the formula

     */



/*
we need to store all the users -> created arraylist of Users
we know that we're gonna have to find a specific person in the list of Users -> that's why we created FindUserIndex
RecordUserInfo -> record user information for a specific movie. It goes through all movie files, records all the information, saves it in Users arraylist.

 */

/*
New advice on 1/8/21:
Keep reading this code and I'll learn it, like maybe every 2 hours
once you FULLY understand aka know why every line is there, you can redo this project
 */


   /*
    think through every step
    believe in yourself
    don't write lines without thinking
    don't be impatient
    most of the read line errors are fixed by clicking
    tip: copy code, change as little code from the original as possible, then change up the variables.
    if something is not working, you have to understand what's not working
    if you have any doubt with the lines, ask Davyd
     */

//TODO: get rid of zeros in output -> don't record movies with 0 rating - done!
//TODO: Inside of RecordUserInfo, Calculate mean and SD. THen assign mean and SD
//TODO: Do the same for entire array of users who watched Zootopia
//TODO: Read this code many times
//TODO: Find Eij and Pearson's coefficient

